# Lista para armazenar os changesets que não retornam resultados
changesets_vazios <- c()
# Valor de changeset_id a ser evitado
changeset_id_evitado <- c(149048503, 142055347, 144440738, 137264436, 150985417, 149008008, 148266830, 118237095, 118237010, 109529140, 89710452, 89710271, 89709768, 89370718, 89369859, 89369168, 88581261, 88510801, 88424727, 87802062, 144418501, 144418447, 144418381, 142157944, 135320215, 135319044, 129533055, 89710267, 89062718, 89062630, 88751476, 88509391, 88509318, 88509168, 88509102, 88509048, 86375858, 86375612
, 85821545, 85796055, 137305694, 136760884, 136760816, 136476252, 118398046, 110361450, 89325722, 89325398)  # Substitua x pelo valor desejado / Este erro precisa ser corrigido.
# Iterar sobre cada linha da tabela YM_Dados
for (i in 1:nrow(YM_Dados)) {
# Verificar se o changeset_id é igual ao valor a ser evitado
if (YM_Dados$id[i] %in% changeset_id_evitado) {
cat("Pulando a consulta para o changeset_id", changeset_id_evitado, "\n")
next  # Pular para a próxima iteração do loop
}
# Consultar o Overpass API para cada changeset_id e usuário
resultado <- consultar_overpass(YM_Dados$user[i], YM_Dados$id[i],
YM_Dados$min_lat[i], YM_Dados$min_lon[i],
YM_Dados$max_lat[i], YM_Dados$max_lon[i])
# Verificar se o resultado está vazio
if (nrow(resultado) == 0) {
# Se estiver vazio, armazenar o changeset_id na lista de changesets vazios
changesets_vazios <- c(changesets_vazios, YM_Dados$id[i])
} else {
# Verificar e garantir que todos os resultados tenham as mesmas colunas
colunas_resultado <- colnames(resultado)
colunas_resultado_comuns <- Reduce(intersect, lapply(resultados, colnames))
colunas_a_adicionar <- setdiff(colunas_resultado_comuns, colunas_resultado)
for (coluna in colunas_a_adicionar) {
resultado[[coluna]] <- NA
}
# Armazenar o resultado na lista
resultados[[i]] <- resultado
}
}
# Verificar quais changesets não retornaram resultados
print("Changesets sem resultados:")
print(changesets_vazios)
# Remover as entradas vazias da lista de resultados
resultados <- resultados[!sapply(resultados, is.null)]
# Verificar se há resultados
if (length(resultados) > 0) {
# Unir os resultados em um único data frame
YM_Changesets <- bind_rows(resultados)
}
View(YM_Changesets)
View(Youth_Users)
View(YM_Users)
View(YM_Dados)
knitr::opts_chunk$set(echo = TRUE)
# Índices das linhas a serem subtraídas
indices_subtraidos <- c(9, 10, 13, 14, 21, 22, 31, 34, 35, 41)
# Criar uma nova tabela sem as linhas especificadas
YM_Users_Error <- subset(YM_Users, !seq_along(YM_Users$Nome) %in% indices_subtraidos)
View(YM_Users_Error)
# Índices das linhas a serem subtraídas
indices_subtraidos <- c(9, 10, 13, 14, 21, 22, 31, 34, 35, 41)
# Criar uma nova tabela sem as linhas especificadas
YM_Users_Error <- YM_Users$Nome[indices_subtraidos, ]
# Índices das linhas a serem subtraídas
indices_subtraidos <- c(9, 10, 13, 14, 21, 22, 31, 34, 35, 41)
# Criar uma nova tabela sem as linhas especificadas
YM_Users_Error <- YM_Users[indices_subtraidos, ]
# Índices das linhas a serem subtraídas
indices_subtraidos <- c(9, 10, 13, 14, 21, 22, 31, 34, 35, 41)
# Criar uma nova tabela sem as linhas especificadas
YM_Users_Error <- data.frame(YM_Users[indices_subtraidos, ])
View(YM_Users_Error)
View(YM_Dados)
View(YM_Users)
View(Youth_Users)
# Índices das linhas a serem subtraídas
indices_subtraidos <- c(9, 10, 13, 14, 21, 22, 31, 34, 35, 41)
# Criar uma nova tabela sem as linhas especificadas
YM_Users_Error <- data.frame(Youth_Users$username_osm[indices_subtraidos, ])
knitr::opts_chunk$set(echo = TRUE)
YM_Users <- data.frame(
Nome = character()
)
Youth_Users <- read.csv("cadastro_YM.csv", header = TRUE)
users <- Youth_Users$username_osm
YM_Users <- data.frame(Nome = users, check.names = FALSE)
YM_Users <- YM_Users[-c(9, 10, 13, 14, 21, 22, 31, 34, 35, 41), ]
YM_Users <- data.frame(Nome = YM_Users, check.names = FALSE)
print(YM_Users)
library(httr)
library(jsonlite)
library(dplyr)
get_user_info <- function(username) {
dados_brutos <- list()
for (user in username) {
# Defina o UID do usuário do OpenStreetMap que você deseja consultar
uid_usuario <- URLencode(user)
# Faça a solicitação à API de Edições para obter o histórico de edições do usuário pelo UID
url <- paste0("https://api.openstreetmap.org/api/0.6/changesets?display_name=", uid_usuario)
cat("URL da consulta:", url, "\n") # Imprime a URL
resposta <- GET(url)
# Verifique se a solicitação foi bem-sucedida
stop_for_status(resposta)
# Extrair o conteúdo da resposta (JSON)
conteudo <- content(resposta, "text", encoding = "UTF-8")
# Analisar o JSON
dados_json <- fromJSON(conteudo)
# Adicionar uma coluna com o nome do usuário
dados_json$changesets.user <- user
dados_brutos[[user]] <- dados_json$changesets
}
# Converter a lista de dataframes em um único dataframe
dados_df <- bind_rows(dados_brutos)
# Retornar o dataframe
return(dados_df)
}
# Obter os nomes de usuário da tabela YM_Users
usernames <- YM_Users$Nome
# Chamar a função get_user_info com os nomes de usuário
YM_Dados <- get_user_info(usernames)
library(httr)
library(jsonlite)
library(dplyr)
# Função para consultar o Overpass API para um changeset específico de um usuário específico
consultar_overpass <- function(username, changeset_id, min_lat, min_lon, max_lat, max_lon) {
# Construir a consulta Overpass API usando a função opq()
overpass_query <- paste0("[out:json];
nwr(", min_lat, ",", min_lon, ",", max_lat, ",", max_lon, ")(user:'", username, "')(if: changeset() == ", changeset_id, ");
out meta;")
cat("Consulta Overpass Query:", overpass_query, "\n")  # Imprimir a consulta
url <- paste0("https://overpass-api.de/api/interpreter?data=", URLencode(overpass_query))
cat("URL da consulta:", url, "\n")  # Imprimir a URL
resposta <- GET(url)
# Verificar se a solicitação foi bem-sucedida
stop_for_status(resposta)
# Extrair o conteúdo da resposta
conteudo <- content(resposta, "text", encoding = "UTF-8")
# Converter o conteúdo JSON em um data frame
overpass_data <- fromJSON(conteudo)
return(as.data.frame(overpass_data))
}
# Lista para armazenar os resultados
resultados <- list()
# Lista para armazenar os changesets que não retornam resultados
changesets_vazios <- c()
# Valor de changeset_id a ser evitado
changeset_id_evitado <- c(149048503, 142055347, 144440738, 137264436, 150985417, 149008008, 148266830, 118237095, 118237010, 109529140, 89710452, 89710271, 89709768, 89370718, 89369859, 89369168, 88581261, 88510801, 88424727, 87802062, 144418501, 144418447, 144418381, 142157944, 135320215, 135319044, 129533055, 89710267, 89062718, 89062630, 88751476, 88509391, 88509318, 88509168, 88509102, 88509048, 86375858, 86375612
, 85821545, 85796055, 137305694, 136760884, 136760816, 136476252, 118398046, 110361450, 89325722, 89325398)  # Substitua x pelo valor desejado / Este erro precisa ser corrigido.
# Iterar sobre cada linha da tabela YM_Dados
for (i in 1:nrow(YM_Dados)) {
# Verificar se o changeset_id é igual ao valor a ser evitado
if (YM_Dados$id[i] %in% changeset_id_evitado) {
cat("Pulando a consulta para o changeset_id", changeset_id_evitado, "\n")
next  # Pular para a próxima iteração do loop
}
# Consultar o Overpass API para cada changeset_id e usuário
resultado <- consultar_overpass(YM_Dados$user[i], YM_Dados$id[i],
YM_Dados$min_lat[i], YM_Dados$min_lon[i],
YM_Dados$max_lat[i], YM_Dados$max_lon[i])
# Verificar se o resultado está vazio
if (nrow(resultado) == 0) {
# Se estiver vazio, armazenar o changeset_id na lista de changesets vazios
changesets_vazios <- c(changesets_vazios, YM_Dados$id[i])
} else {
# Verificar e garantir que todos os resultados tenham as mesmas colunas
colunas_resultado <- colnames(resultado)
colunas_resultado_comuns <- Reduce(intersect, lapply(resultados, colnames))
colunas_a_adicionar <- setdiff(colunas_resultado_comuns, colunas_resultado)
for (coluna in colunas_a_adicionar) {
resultado[[coluna]] <- NA
}
# Armazenar o resultado na lista
resultados[[i]] <- resultado
}
}
# Verificar quais changesets não retornaram resultados
print("Changesets sem resultados:")
print(changesets_vazios)
# Remover as entradas vazias da lista de resultados
resultados <- resultados[!sapply(resultados, is.null)]
# Verificar se há resultados
if (length(resultados) > 0) {
# Unir os resultados em um único data frame
YM_Changesets <- bind_rows(resultados)
}
# Índices das linhas a serem subtraídas
indices_subtraidos <- c(9, 10, 13, 14, 21, 22, 31, 34, 35, 41)
# Criar uma tabela com as linhas selecionadas
YM_Users_Error <- data.frame(username_osm = Youth_Users$username_osm[indices_subtraidos])
View(YM_Users_Error)
View(YM_Dados)
View(YM_Users)
View(YM_Users)
View(YM_Users)
View(YM_Users_Error)
View(Youth_Users)
# Índices das linhas a serem subtraídas
indices_subtraidos <- c(9, 10, 13, 14, 21, 22, 31, 34, 35, 41)
# Criar uma tabela com as linhas selecionadas
YM_Users_Error <- data.frame(
nome_completo = Youth_Users$Nome.Completo[indices_subtraidos],
username_osm = Youth_Users$username_osm[indices_subtraidos]
)
View(YM_Users_Error)
View(YM_Dados)
# Lista de valores de id para selecionar
id_para_selecionar <- c(149048503, 142055347, 144440738, 137264436, 150985417, 149008008, 148266830, 118237095, 118237010, 109529140, 89710452, 89710271, 89709768, 89370718, 89369859, 89369168, 88581261, 88510801, 88424727, 87802062, 144418501, 144418447, 144418381, 142157944, 135320215, 135319044, 129533055, 89710267, 89062718, 89062630, 88751476, 88509391, 88509318, 88509168, 88509102, 88509048, 86375858, 86375612 , 85821545, 85796055, 137305694, 136760884, 136760816, 136476252, 118398046, 110361450, 89325722, 89325398)
# Selecionar linhas com base nos valores de id
linhas_selecionadas <- YM_Dados[YM_Dados$id %in% id_para_selecionar, ]
View(linhas_selecionadas)
# Lista de valores de id para selecionar
id_para_selecionar <- c(149048503, 142055347, 144440738, 137264436, 150985417, 149008008, 148266830, 118237095, 118237010, 109529140, 89710452, 89710271, 89709768, 89370718, 89369859, 89369168, 88581261, 88510801, 88424727, 87802062, 144418501, 144418447, 144418381, 142157944, 135320215, 135319044, 129533055, 89710267, 89062718, 89062630, 88751476, 88509391, 88509318, 88509168, 88509102, 88509048, 86375858, 86375612 , 85821545, 85796055, 137305694, 136760884, 136760816, 136476252, 118398046, 110361450, 89325722, 89325398)
# Selecionar linhas com base nos valores de id
YM_Changesets_Error <- YM_Dados[YM_Dados$id %in% id_para_selecionar, ]
# Lista de índices das colunas que você deseja excluir
colunas_para_excluir <- c(1,2,4)
# Excluir as colunas especificadas
YM_Changesets_Test <- YM_Changesets[, -colunas_para_excluir]
View(YM_Changesets_Test)
View(YM_Dados)
# Lista de índices das colunas que você deseja excluir
colunas_para_excluir <- c(1,2,4)
# Excluir as colunas especificadas
YM_Changesets <- YM_Changesets[, -colunas_para_excluir]
# Lista de índices das colunas que você deseja excluir
colunas_para_excluir <- c(1,2,4)
# Excluir as colunas especificadas
YM_Changesets <- YM_Changesets[, -colunas_para_excluir]
limpar_nomes_colunas <- function(df) {
nomes_colunas <- colnames(df)
novos_nomes_colunas <- gsub("[^[:alnum:]_]", "_", nomes_colunas)
colnames(df) <- novos_nomes_colunas
return(df)
}
YM_Changesets <- limpar_nomes_colunas(YM_Changesets)
View(YM_Changesets)
# Lista de índices das colunas que você deseja excluir
colunas_para_excluir <- c(1,2,4)
# Excluir as colunas especificadas
YM_Changesets <- YM_Changesets[, -colunas_para_excluir]
limpar_nomes_colunas <- function(df) {
nomes_colunas <- colnames(df)
novos_nomes_colunas <- gsub("[^[:alnum:]_$:]", "_", nomes_colunas)
colnames(df) <- novos_nomes_colunas
return(df)
}
YM_Changesets <- limpar_nomes_colunas(YM_Changesets)
View(YM_Changesets)
limpar_nomes_colunas <- function(df) {
nomes_colunas <- colnames(df)
# Substituir caracteres especiais por _
novos_nomes_colunas <- gsub("[^[:alnum:]_]", "_", nomes_colunas)
# Substituir $ e : por _
novos_nomes_colunas <- gsub("[$:]", "_", novos_nomes_colunas)
colnames(df) <- novos_nomes_colunas
return(df)
}
YM_Changesets <- limpar_nomes_colunas(YM_Changesets)
View(YM_Changesets)
limpar_nomes_colunas <- function(df) {
nomes_colunas <- colnames(df)
# Substituir caracteres especiais por _
novos_nomes_colunas <- gsub("[^[:alnum:]_]", "_", nomes_colunas)
# Substituir $ e : por _
novos_nomes_colunas <- gsub("[$:]", "_", nomes_colunas)
colnames(df) <- novos_nomes_colunas
return(df)
}
YM_Changesets <- limpar_nomes_colunas(YM_Changesets)
limpar_nomes_colunas <- function(df) {
nomes_colunas <- colnames(df)
# Substituir caracteres especiais por _
novos_nomes_colunas <- gsub("[^[:alnum:]_]", "_", nomes_colunas)
# Substituir $ e : por _
novos_nomes_colunas <- gsub("[$:]", "_", novos_nomes_colunas)
colnames(df) <- novos_nomes_colunas
return(df)
}
YM_Changesets <- limpar_nomes_colunas(YM_Changesets)
limpar_nomes_colunas <- function(df) {
nomes_colunas <- colnames(df)
# Substituir caracteres especiais por _
novos_nomes_colunas <- gsub("[^[:alnum:]_]", "_", nomes_colunas)
# Substituir $ por _
novos_nomes_colunas <- gsub("\\$", "_", novos_nomes_colunas)
# Substituir : por _
novos_nomes_colunas <- gsub(":", "_", novos_nomes_colunas)
colnames(df) <- novos_nomes_colunas
return(df)
}
YM_Changesets <- limpar_nomes_colunas(YM_Changesets)
limpar_nomes_colunas <- function(df) {
nomes_colunas <- colnames(df)
# Substituir caracteres especiais por _
novos_nomes_colunas <- gsub("[^[:alnum:]_]", "_", nomes_colunas)
# Substituir $ por _
novos_nomes_colunas <- gsub("\\$", "_", novos_nomes_colunas)
# Substituir : por _
novos_nomes_colunas <- gsub(":", "_", novos_nomes_colunas)
colnames(df) <- novos_nomes_colunas
return(df)
}
YM_Changesets <- limpar_nomes_colunas(YM_Changesets)
View(YM_Changesets)
knitr::opts_chunk$set(echo = TRUE)
YM_Users <- data.frame(
Nome = character()
)
Youth_Users <- read.csv("cadastro_YM.csv", header = TRUE)
users <- Youth_Users$username_osm
YM_Users <- data.frame(Nome = users, check.names = FALSE)
YM_Users <- YM_Users[-c(9, 10, 13, 14, 21, 22, 31, 34, 35, 41), ]
YM_Users <- data.frame(Nome = YM_Users, check.names = FALSE)
print(YM_Users)
library(httr)
library(jsonlite)
library(dplyr)
get_user_info <- function(username) {
dados_brutos <- list()
for (user in username) {
# Defina o UID do usuário do OpenStreetMap que você deseja consultar
uid_usuario <- URLencode(user)
# Faça a solicitação à API de Edições para obter o histórico de edições do usuário pelo UID
url <- paste0("https://api.openstreetmap.org/api/0.6/changesets?display_name=", uid_usuario)
cat("URL da consulta:", url, "\n") # Imprime a URL
resposta <- GET(url)
# Verifique se a solicitação foi bem-sucedida
stop_for_status(resposta)
# Extrair o conteúdo da resposta (JSON)
conteudo <- content(resposta, "text", encoding = "UTF-8")
# Analisar o JSON
dados_json <- fromJSON(conteudo)
# Adicionar uma coluna com o nome do usuário
dados_json$changesets.user <- user
dados_brutos[[user]] <- dados_json$changesets
}
# Converter a lista de dataframes em um único dataframe
dados_df <- bind_rows(dados_brutos)
# Retornar o dataframe
return(dados_df)
}
# Obter os nomes de usuário da tabela YM_Users
usernames <- YM_Users$Nome
# Chamar a função get_user_info com os nomes de usuário
YM_Dados <- get_user_info(usernames)
library(httr)
library(jsonlite)
library(dplyr)
# Função para consultar o Overpass API para um changeset específico de um usuário específico
consultar_overpass <- function(username, changeset_id, min_lat, min_lon, max_lat, max_lon) {
# Construir a consulta Overpass API usando a função opq()
overpass_query <- paste0("[out:json];
nwr(", min_lat, ",", min_lon, ",", max_lat, ",", max_lon, ")(user:'", username, "')(if: changeset() == ", changeset_id, ");
out meta;")
cat("Consulta Overpass Query:", overpass_query, "\n")  # Imprimir a consulta
url <- paste0("https://overpass-api.de/api/interpreter?data=", URLencode(overpass_query))
cat("URL da consulta:", url, "\n")  # Imprimir a URL
resposta <- GET(url)
# Verificar se a solicitação foi bem-sucedida
stop_for_status(resposta)
# Extrair o conteúdo da resposta
conteudo <- content(resposta, "text", encoding = "UTF-8")
# Converter o conteúdo JSON em um data frame
overpass_data <- fromJSON(conteudo)
return(as.data.frame(overpass_data))
}
# Lista para armazenar os resultados
resultados <- list()
# Lista para armazenar os changesets que não retornam resultados
changesets_vazios <- c()
# Valor de changeset_id a ser evitado
changeset_id_evitado <- c(149048503, 142055347, 144440738, 137264436, 150985417, 149008008, 148266830, 118237095, 118237010, 109529140, 89710452, 89710271, 89709768, 89370718, 89369859, 89369168, 88581261, 88510801, 88424727, 87802062, 144418501, 144418447, 144418381, 142157944, 135320215, 135319044, 129533055, 89710267, 89062718, 89062630, 88751476, 88509391, 88509318, 88509168, 88509102, 88509048, 86375858, 86375612
, 85821545, 85796055, 137305694, 136760884, 136760816, 136476252, 118398046, 110361450, 89325722, 89325398)  # Substitua x pelo valor desejado / Este erro precisa ser corrigido.
# Iterar sobre cada linha da tabela YM_Dados
for (i in 1:nrow(YM_Dados)) {
# Verificar se o changeset_id é igual ao valor a ser evitado
if (YM_Dados$id[i] %in% changeset_id_evitado) {
cat("Pulando a consulta para o changeset_id", changeset_id_evitado, "\n")
next  # Pular para a próxima iteração do loop
}
# Consultar o Overpass API para cada changeset_id e usuário
resultado <- consultar_overpass(YM_Dados$user[i], YM_Dados$id[i],
YM_Dados$min_lat[i], YM_Dados$min_lon[i],
YM_Dados$max_lat[i], YM_Dados$max_lon[i])
# Verificar se o resultado está vazio
if (nrow(resultado) == 0) {
# Se estiver vazio, armazenar o changeset_id na lista de changesets vazios
changesets_vazios <- c(changesets_vazios, YM_Dados$id[i])
} else {
# Verificar e garantir que todos os resultados tenham as mesmas colunas
colunas_resultado <- colnames(resultado)
colunas_resultado_comuns <- Reduce(intersect, lapply(resultados, colnames))
colunas_a_adicionar <- setdiff(colunas_resultado_comuns, colunas_resultado)
for (coluna in colunas_a_adicionar) {
resultado[[coluna]] <- NA
}
# Armazenar o resultado na lista
resultados[[i]] <- resultado
}
}
# Verificar quais changesets não retornaram resultados
print("Changesets sem resultados:")
print(changesets_vazios)
# Remover as entradas vazias da lista de resultados
resultados <- resultados[!sapply(resultados, is.null)]
# Verificar se há resultados
if (length(resultados) > 0) {
# Unir os resultados em um único data frame
YM_Changesets <- bind_rows(resultados)
}
# Índices das linhas a serem subtraídas
indices_subtraidos <- c(9, 10, 13, 14, 21, 22, 31, 34, 35, 41)
# Criar uma tabela com as linhas selecionadas
YM_Users_Error <- data.frame(
nome_completo = Youth_Users$Nome.Completo[indices_subtraidos],
username_osm = Youth_Users$username_osm[indices_subtraidos]
)
# Lista de valores de id para selecionar
id_para_selecionar <- c(149048503, 142055347, 144440738, 137264436, 150985417, 149008008, 148266830, 118237095, 118237010, 109529140, 89710452, 89710271, 89709768, 89370718, 89369859, 89369168, 88581261, 88510801, 88424727, 87802062, 144418501, 144418447, 144418381, 142157944, 135320215, 135319044, 129533055, 89710267, 89062718, 89062630, 88751476, 88509391, 88509318, 88509168, 88509102, 88509048, 86375858, 86375612 , 85821545, 85796055, 137305694, 136760884, 136760816, 136476252, 118398046, 110361450, 89325722, 89325398)
# Selecionar linhas com base nos valores de id
YM_Changesets_Error <- YM_Dados[YM_Dados$id %in% id_para_selecionar, ]
# Lista de índices das colunas que você deseja excluir
colunas_para_excluir <- c(1,2,4)
# Excluir as colunas especificadas
YM_Changesets <- YM_Changesets[, -colunas_para_excluir]
limpar_nomes_colunas <- function(df) {
nomes_colunas <- colnames(df)
# Substituir caracteres especiais por _
novos_nomes_colunas <- gsub("[^[:alnum:]_]", "_", nomes_colunas)
# Substituir $ por _
novos_nomes_colunas <- gsub("\\$", "_", novos_nomes_colunas)
# Substituir : por _
novos_nomes_colunas <- gsub(":", "_", novos_nomes_colunas)
colnames(df) <- novos_nomes_colunas
return(df)
}
YM_Changesets <- limpar_nomes_colunas(YM_Changesets)
View(YM_Changesets)
library(httr)
library(jsonlite)
library(dplyr)
# Função para consultar o Overpass API para um changeset específico de um usuário específico
consultar_overpass <- function(username, changeset_id, min_lat, min_lon, max_lat, max_lon) {
# Construir a consulta Overpass API usando a função opq()
overpass_query <- paste0("[out:json];
nwr(", min_lat, ",", min_lon, ",", max_lat, ",", max_lon, ")(user:'", username, "')(if: changeset() == ", changeset_id, ");
out meta;")
cat("Consulta Overpass Query:", overpass_query, "\n")  # Imprimir a consulta
url <- paste0("https://overpass-api.de/api/interpreter?data=", URLencode(overpass_query))
cat("URL da consulta:", url, "\n")  # Imprimir a URL
resposta <- GET(url)
# Verificar se a solicitação foi bem-sucedida
stop_for_status(resposta)
# Extrair o conteúdo da resposta
conteudo <- content(resposta, "text", encoding = "UTF-8")
# Converter o conteúdo JSON em um data frame
overpass_data <- fromJSON(conteudo)
return(as.data.frame(overpass_data))
}
# Lista para armazenar os resultados
resultados <- list()
# Lista para armazenar os changesets que não retornam resultados
changesets_vazios <- c()
# Valor de changeset_id a ser evitado
changeset_id_evitado <- c(149048503, 142055347, 144440738, 137264436, 150985417, 149008008, 148266830, 118237095, 118237010, 109529140, 89710452, 89710271, 89709768, 89370718, 89369859, 89369168, 88581261, 88510801, 88424727, 87802062, 144418501, 144418447, 144418381, 142157944, 135320215, 135319044, 129533055, 89710267, 89062718, 89062630, 88751476, 88509391, 88509318, 88509168, 88509102, 88509048, 86375858, 86375612
, 85821545, 85796055, 137305694, 136760884, 136760816, 136476252, 118398046, 110361450, 89325722, 89325398)  # Substitua x pelo valor desejado / Este erro precisa ser corrigido.
# Iterar sobre cada linha da tabela YM_Dados
for (i in 1:nrow(YM_Dados)) {
# Verificar se o changeset_id é igual ao valor a ser evitado
if (YM_Dados$id[i] %in% changeset_id_evitado) {
cat("Pulando a consulta para o changeset_id", changeset_id_evitado, "\n")
next  # Pular para a próxima iteração do loop
}
# Consultar o Overpass API para cada changeset_id e usuário
resultado <- consultar_overpass(YM_Dados$user[i], YM_Dados$id[i],
YM_Dados$min_lat[i], YM_Dados$min_lon[i],
YM_Dados$max_lat[i], YM_Dados$max_lon[i])
# Verificar se o resultado está vazio
if (nrow(resultado) == 0) {
# Se estiver vazio, armazenar o changeset_id na lista de changesets vazios
changesets_vazios <- c(changesets_vazios, YM_Dados$id[i])
} else {
# Verificar e garantir que todos os resultados tenham as mesmas colunas
colunas_resultado <- colnames(resultado)
colunas_resultado_comuns <- Reduce(intersect, lapply(resultados, colnames))
colunas_a_adicionar <- setdiff(colunas_resultado_comuns, colunas_resultado)
for (coluna in colunas_a_adicionar) {
resultado[[coluna]] <- NA
}
# Armazenar o resultado na lista
resultados[[i]] <- resultado
}
}
# Verificar quais changesets não retornaram resultados
print("Changesets sem resultados:")
print(changesets_vazios)
# Remover as entradas vazias da lista de resultados
resultados <- resultados[!sapply(resultados, is.null)]
# Verificar se há resultados
if (length(resultados) > 0) {
# Unir os resultados em um único data frame
YM_Changesets <- bind_rows(resultados)
# Iterar sobre cada linha do dataframe YM_Changesets
for (i in 1:nrow(YM_Changesets)) {
# Extrair o dataframe elements.tags de cada linha
elements_tags <- YM_Changesets$elements.tags[[i]]
# Verificar se elements_tags não é nulo
if (!is.null(elements_tags)) {
# Converter elements_tags em um dataframe
elements_tags_df <- as.data.frame(t(elements_tags))
# Renomear as colunas, se desejar
# colnames(elements_tags_df) <- c("nova_coluna_1", "nova_coluna_2", ...)
# Combinar elements_tags_df com o dataframe YM_Changesets
YM_Changesets <- cbind(YM_Changesets, elements_tags_df)
}
}
# Remover a coluna elements.tags do dataframe YM_Changesets
YM_Changesets <- YM_Changesets[!names(YM_Changesets) %in% "elements.tags"]
}
